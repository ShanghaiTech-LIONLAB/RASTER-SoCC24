#include "IndexManager.h"

namespace raster
{

// --- begin implementation of region index management module ---
Region::Region() : m_mask_id(0), m_deflate_level(0), m_ndims(0) {}
Region::Region(int mask_id, int ndims) : m_mask_id(mask_id), m_deflate_level(0), m_ndims(ndims) {};

void Region::add_region(file_chunk_t&& blk, int id, bool related)
{
    if (related)
    {
        m_related_chunk_ids.push_back(id);
    }
    else
    {
        m_chunks.push_back(blk);
        m_chunk_ids.push_back(id);
    }
}

void Region::set_deflate(int level) { m_deflate_level = level; }

int Region::get_deflate_level() const { return m_deflate_level; }

void Region::set_maskid(int id) { m_mask_id = id; }

int Region::get_maskid() const { return m_mask_id; }

void Region::set_ndims(int ndims) { m_ndims = ndims; }

int Region::get_ndims() const { return m_ndims; }

int Region::get_nchunks() const { return m_chunks.size(); }

int Region::get_id(int id) const { return m_chunk_ids[id]; }

const std::vector<file_chunk_t>& Region::get_regions() const { return m_chunks; }

const file_chunk_t& Region::get_region(int id) const { return m_chunks[id]; }

const std::vector<int>& Region::get_related_ids() const { return m_related_chunk_ids; }
// --- end of implementation of region index management module ---


// blklist: a list of chunk information, generated by Mesh.partition()
// mask_ids: a vector contains all mask values
// varndims: number of dimensions of this variable
// original_size: original (un-partitioned) chunksize, such as (32, 32, 128) for a 3D var
// return value: l = [Region]; where l[0]=mixed_chunks, l[1:]=region_1, region_2, ...
std::vector<Region> construct_region_chunks(const chunk_info_list& info_list, std::vector<int>& mask_ids, int varndims, std::vector<size_t> chunkshape)
{
    std::map<int, Region> regions;
    int curr_blkid = 0;
    std::vector<size_t> curr_start(varndims), curr_shape(chunkshape);
    
    regions.insert({REGION_MIXED_ID, Region(REGION_MIXED_ID, varndims)});
    for (int i = 0; i < mask_ids.size(); i++)
        regions.insert({mask_ids[i], Region(mask_ids[i], varndims)});

    for (auto& row : info_list)
    {
        for (auto& blkptr : row)
        {
            curr_start[varndims - 2] = blkptr->m_start_row;
            curr_start[varndims - 1] = blkptr->m_start_col;
            curr_shape[varndims - 2] = blkptr->m_size_row;
            curr_shape[varndims - 1] = blkptr->m_size_col;

            if (blkptr->m_type != BLOCK_TYPE::MIXED)
            {
                regions[blkptr->get_major_index()].add_region(file_chunk_t(varndims, curr_start, curr_shape), curr_blkid, false);
            }
            else
            {
                regions[REGION_MIXED_ID].add_region(file_chunk_t(varndims, curr_start, curr_shape), curr_blkid, false);
                for (auto& key : blkptr->keys())
                    regions[key].add_region(file_chunk_t(varndims, curr_start, curr_shape), curr_blkid, true);
            }
            curr_blkid++;
        }
    }
    std::vector<Region> ret;
    for (auto& kv : regions)
        ret.push_back(kv.second);
    return ret;
}

// write metadata for given region, the metadata is a 2D integer array with following structure
// blk_1_id blk_1_start[0], blk_1_start[1],... blk_1_count[0], blk_1_count[1], ...
// blk_2_id blk_2_start[0], blk_2_start[1],... blk_2_count[0], blk_2_count[1], ...
// ...
// blk_n_id blk_n_start[0], blk_n_start[1],... blk_n_count[0], blk_n_count[1], ...
void construct_region_meta(Region& region, int* nrows, int* ncols, size_t* &metadata)
{
    int pos = 0;
    *nrows = region.get_nchunks();
    *ncols = 2 * region.get_ndims() + 1;
    metadata = new size_t[(*nrows) * (*ncols)];
    for (int i = 0; i < *nrows; i++)
    {
        file_chunk_t blk = region.get_region(i);
        metadata[pos++] = region.get_id(i);
        for (auto& si : blk.m_start) 
            metadata[pos++] = si;
        for (auto& ci : blk.m_chunksize) 
            metadata[pos++] = ci;
    }
}

// returns the number of mixed chunks related to `region`, and their chunk ids
void construct_region_relation(Region& region, int* nrelated_chks, int* &related_ids)
{
    auto relations = region.get_related_ids();
    *nrelated_chks = relations.size();
    related_ids = new int[*nrelated_chks];
    memcpy(related_ids, &relations[0], sizeof(int) * (*nrelated_chks));
}


} // end namespace raster